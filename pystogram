#!/usr/bin/env python

"""
pystogram -- Display time-series histograms of Apache-style log files on the command-line.

Sample output:

    $ grep lolcat /var/log/access.log | pystogram
    
    2013-07-01 07:12  ##                                                   
    2013-07-01 07:13  ####                                                700
    2013-07-01 07:14  #######                                            1234
    2013-07-01 07:15  ############################                       6873
    2013-07-01 07:16  ##############                                     3928
    2013-07-01 07:17  #################                                  4152
    2013-07-01 07:18  ###############################################   16432
    2013-07-01 07:19  ######                                               35
    2013-07-01 07:20  #                                                     7
"""

import calendar
import collections
import datetime
import fileinput
import math
import re


#FIXME: Determine width and height from command-line options or console dimensions
WIDTH = 80
HEIGHT = None  # unlimited

# FIXME: i18n/l10n?
MONTHS = dict({ (v,k) for k,v in enumerate(calendar.month_abbr) })

# FIXME: Make the regex configurable (how?)
TIMESTAMP_REGEX = re.compile(
    r' \[(?P<day>\d{2})/(?P<month>\w{3})/(?P<year>\d{4}):'
    r'(?P<hour>\d{2}):(?P<minute>\d{2}):(?P<second>\d{2})(?P<offset>\s?(\+|-)\d+)?\] '
)


class Tree(collections.defaultdict):
    """
    A basic prefix tree (trie) using defaultdict.
    """
    def __init__(self, value=0):
        super(Tree, self).__init__(Tree)
        self.value = value

    # FIXME: Is traverse the right method? Should it take an index? Should we have a least()/greatest() or left()/right()?
    def traverse(self, index):
        if len(self) == 0:
            return []
        keys = sorted(self.keys())
        key = keys[index]
        nodes = self[key].traverse(index)
        nodes.insert(0, key)
        return nodes

    def find(self, keys):
        if not keys:
            return self
        key = keys.pop(0)
        return self[key].find(keys)

    def sum(self):
        count = self.value
        for key in self.keys():
            count += self[key].sum()
        return count

YEAR = 60 * 60 * 24 * 365
MONTH = 60 * 60 * 24 * 30
DAY = 60 * 60 * 24
HOUR = 60 * 60
MINUTE = 60
SECOND = 1


def guess_resolution(seconds):
    if seconds > YEAR:
        return YEAR
    elif seconds > MONTH:
        return MONTH
    elif seconds > DAY:
        return DAY
    elif seconds > HOUR:
        return HOUR
    elif seconds > MINUTE:
        return MINUTE
    else:
        return SECOND


def timedelta_from_seconds(total_seconds):
    return datetime.timedelta(days=total_seconds / 86400, seconds=total_seconds % 86400)


class Bucket(object):
    def __init__(self, start, resolution):
        self.start = start
        self.resolution = resolution
        self.value = 0
        self.format = '%Y'
        if resolution < YEAR:
            self.format += '-%m'
        if resolution < MONTH:
            self.format += '-%d'
        if resolution < DAY:
            self.format += ' %H'
        if resolution < HOUR:
            self.format += ':%M'
        if resolution < MINUTE:
            self.format += ':%S'

    def __str__(self):
        return '[%s] %s' % (self.timestamp, self.value)

    @property
    def timestamp(self):
        return self.start.strftime(self.format)

    # FIXME: What to call this?
    @property
    def parts(self):
        parts = [self.start.year]
        if self.resolution < YEAR:
            parts.append(self.start.month)
        if self.resolution < MONTH:
            parts.append(self.start.day)
        if self.resolution < DAY:
            parts.append(self.start.hour)
        if self.resolution < HOUR:
            parts.append(self.start.minute)
        if self.resolution < MINUTE:
            parts.append(self.start.second)
        return parts


class Histogram(object):
    def __init__(self, tree, resolution):
        self.tree = tree
        self.resolution = resolution
        self.interval = timedelta_from_seconds(resolution)

    @property
    def buckets(self):
        first_sample = datetime.datetime(*self.tree.traverse(0))
        last_sample = datetime.datetime(*self.tree.traverse(-1))
        sample = first_sample
        while sample <= last_sample:
            bucket = Bucket(sample, self.resolution)
            node = self.tree.find(bucket.parts)
            bucket.value = node.sum()
            yield bucket
            sample += self.interval

def main():
    root = Tree()

    for line in fileinput.input():
        match = TIMESTAMP_REGEX.search(line)
        if match:
            # FIXME: Could this be a method on Tree?
            node = root
            node = node[int(match.group('year'))]
            node = node[MONTHS[match.group('month')]]
            node = node[int(match.group('day'))]
            node = node[int(match.group('hour'))]
            node = node[int(match.group('minute'))]
            node = node[int(match.group('second'))]
            node.value += 1

    # Find the sample space boundaries
    # FIXME: Should this move into Histogram?
    first_sample = datetime.datetime(*root.traverse(0))
    last_sample = datetime.datetime(*root.traverse(-1))

    # Compute the bucket resolution
    # FIXME: Allow this to be specified as a command-line option
    sample_interval = last_sample - first_sample
    total_seconds = sample_interval.total_seconds()
    resolution = guess_resolution(total_seconds)

    histogram = Histogram(root, resolution)

    for bucket in histogram.buckets:
        print bucket

if __name__ == '__main__':
    main()
